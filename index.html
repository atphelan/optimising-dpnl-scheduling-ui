<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DPNL Optimiser</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 700px;
      margin: 40px auto;
      line-height: 1.5;
    }
    .section {
      margin-bottom: 25px;
    }
    .inputs {
      display: none;
      margin-top: 15px;
    }
    label {
      display: block;
      margin: 10px 0;
    }
    input {
      width: 150px;
      margin-left: 10px;
    }
    button {
      margin-right: 10px;
      padding: 6px 12px;
    }
    textarea {
      width: 100%;
      height: 180px;
    }
  </style>
</head>

<body>

<h2>Dual-pulse dual-nucleoside analogue labelling scheduling optimiser</h2>

<div class="section">
  <p>
    This tool estimates the optimal scheduling time for S phase inference 
    based on either observed event counts or measured phase times.
    It uses normalisation to choose the closest series in our simulation
    data by relative cell counts or phase times, and reporting its optimum.
  </p>
</div>

<div class="section">
  <strong>Select input method:</strong><br>
  <button onclick="showCounts()">Use Labelled Cell Counts</button>
  <button onclick="showPhases()">Use Cell Cycle Phase Times</button>
</div>


<!-- COUNTS INPUTS -->
<div id="counts" class="inputs section">
  <h3>Counts-based inputs</h3>
  <p>
    Enter observed counts or relative counts from the experiment. All values must be positive.
  </p>

  <label>Inter-pulse waiting time (hours, must be an integer 1-12):
    <input type="number" id="dt" step="1" min="1">
  </label>

  <label>Single-positive count for label 1:
    <input type="number" id="edu" step="any" min="0.001">
  </label>

  <label>Double-positive count:
    <input type="number" id="dp" step="any" min="0.001">
  </label>

  <label>Single-positive count for label 2:
    <input type="number" id="brdu" step="any" min="0.001">
  </label>

  <label>
  G1-S phase optimisation weighting:
  </label>

  <input
    type="range"
    id="s_weight_slider_counts"
    min="0"
    max="1"
    step="0.01"
    value="0.50"
    oninput="syncWeightFromSliderCounts()"
  >

  <input
    type="number"
    id="s_weight_input_counts"
    min="0"
    max="100"
    step="1"
    value="50"
    oninput="syncWeightFromInputCounts()"
  > %

  <p>
  </p>

  <button onclick="runCounts()">Run optimiser</button>
</div>

<!-- PHASE INPUTS -->
<div id="phases" class="inputs section">
  <h3>Phase-time inputs</h3>
  <p>
    Enter preliminary phase duration estimates. All values must be positive.
    Please note there will be some delay while the optimiser initialises and runs.
  </p>

  <label>G1 phase duration (hours):
    <input type="number" id="tg1" step="any" min="0.1">
  </label>

  <label>S phase duration (hours):
    <input type="number" id="ts" step="any" min="0.1">
  </label>

  <label>Total cycle duration (hours):
    <input type="number" id="tc" step="any" min="0.1">
  </label>


  <label>
  G1-S phase optimisation weighting:
  </label>

  <input
    type="range"
    id="s_weight_slider_phases"
    min="0"
    max="1"
    step="0.01"
    value="0.50"
    oninput="syncWeightFromSliderPhases()"
  >

  <input
    type="number"
    id="s_weight_input_phases"
    min="0"
    max="100"
    step="1"
    value="50"
    oninput="syncWeightFromInputPhases()"
  > %

  <p>
  </p>

  <button onclick="runPhases()">Run optimiser</button>
</div>

<div class="section">
  <h3>Results</h3>
  <p>
    Please note there will be up to a 1-minute delay while the optimiser initialises and runs.
  </p>
  <textarea id="output" readonly></textarea>
</div>

<script>
const API = "https://optimizing-dpnl-scheduling.onrender.com";

function syncWeightFromSliderCounts() {
  const slider = document.getElementById("s_weight_slider_counts");
  const input  = document.getElementById("s_weight_input_counts");
  const label  = document.getElementById("s_weight_label_counts");

  const percent = Math.round(slider.value * 100);

  input.value = percent;
  label.textContent = `(${percent}%)`;
}

function syncWeightFromInputCounts() {
  const slider = document.getElementById("s_weight_slider_counts");
  const input  = document.getElementById("s_weight_input_counts");
  const label  = document.getElementById("s_weight_label_counts");

  let percent = Number(input.value);

  if (isNaN(percent)) percent = 0;
  percent = Math.min(100, Math.max(0, percent));

  slider.value = percent / 100;
  label.textContent = `(${percent}%)`;
}

function getSWeightCounts() {
  return Number(document.getElementById("s_weight_slider_counts").value);
}

function syncWeightFromSliderPhases() {
  const slider = document.getElementById("s_weight_slider_phases");
  const input  = document.getElementById("s_weight_input_phases");
  const label  = document.getElementById("s_weight_label_phases");

  const percent = Math.round(slider.value * 100);

  input.value = percent;
  label.textContent = `(${percent}%)`;
}

function syncWeightFromInputPhases() {
  const slider = document.getElementById("s_weight_slider_phases");
  const input  = document.getElementById("s_weight_input_phases");
  const label  = document.getElementById("s_weight_label_phases");

  let percent = Number(input.value);

  if (isNaN(percent)) percent = 0;
  percent = Math.min(100, Math.max(0, percent));

  slider.value = percent / 100;
  label.textContent = `(${percent}%)`;
}

function getSWeightPhases() {
  return Number(document.getElementById("s_weight_slider_phases").value);
}

function showCounts() {
  document.getElementById("counts").style.display = "block";
  document.getElementById("phases").style.display = "none";
}

function showPhases() {
  document.getElementById("phases").style.display = "block";
  document.getElementById("counts").style.display = "none";
}

async function runCounts() {
  const dt = Number(document.getElementById("dt").value);
  const edu = parseFloat(document.getElementById("edu").value);
  const dp = parseFloat(document.getElementById("dp").value);
  const brdu = parseFloat(document.getElementById("brdu").value);

  if (dt < 1) {
    alert("Pulse interval cannot be less than 1 hour to compare to the simulation data.");
    return;
  }

  if (dt > 12) {
    alert("Pulse interval cannot be greater than 12 hours to compare to the simulation data.");
    return;
  }

  if (!Number.isInteger(dt)) {
    alert("Inter-pulse waiting time must be an integer to compare to simulation data.");
    return;
  }


  if (edu <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  if (dp <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  if (brdu <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  const sw = getSWeight();

  if (sw < 0) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }
  if (sw > 1) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }

  const g1w = 1-sw;

  const params = new URLSearchParams({ dt, edu, dp, brdu, g1w, sw });

  const r = await fetch(`${API}/optimize/counts?${params}`);
  const d = await r.json();

  const tWait = d["Optimal t_wait"];
  const snr = d["SNR k2 from simulation"];

  document.getElementById("output").value =
    `Optimised waiting time between pulses (counts method): ${tWait} hours

  In the simulation data, we found a maximum signal-to-noise ratio of ${snr}
  for inference with a ${g1w*100}% G1 weighting and ${sw*100}% S weighting
  on parameters which produced similar counts to the values provided,
  when simulated with a ${tWait} hour waiting time.`;
}

async function runPhases() {
  const tg1 = parseFloat(document.getElementById("tg1").value);
  const ts  = parseFloat(document.getElementById("ts").value);
  const tc  = parseFloat(document.getElementById("tc").value);

  if (tc <= tg1 + ts) {
    alert("Total cycle duration must be greater than G1 + S phase duration.");
    return;
  }

  const sw = getSWeight();

  if (sw < 0) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }
  if (sw > 1) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }

  const g1w = 1-sw;

  const params = new URLSearchParams({ tg1, ts, tc, g1w, sw });

  const r = await fetch(`${API}/optimize/phases?${params}`);
  const d = await r.json();
  const tWait = d["Optimal t_wait"];
  const snr = d["SNR k2 from simulation"];

  document.getElementById("output").value =
    `Optimised waiting time between pulses (phase times method): ${tWait} hours

  In the simulation data, we found a maximum signal-to-noise ratio of ${snr}
  for inference with a ${g1w*100}% G1 weighting and ${sw*100}% S weighting on 
  cells with relative cycle phase times similar to the values provided,
  when simulated on a 24-hour cycle with a ${tWait * 24/tc} hour waiting time.`;
}
</script>

</body>
</html>
