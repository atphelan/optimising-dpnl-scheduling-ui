<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DPNL Optimiser</title>
  <style>
    body {
      font-family: sans-serif;
      max-width: 700px;
      margin: 40px auto;
      line-height: 1.5;
    }
    .section {
      margin-bottom: 25px;
    }
    .inputs {
      display: none;
      margin-top: 15px;
    }
    label {
      display: block;
      margin: 10px 0;
    }
    input {
      width: 150px;
      margin-left: 10px;
    }
    button {
      margin-right: 10px;
      padding: 6px 12px;
    }
    textarea {
      width: 100%;
      height: 180px;
    }
  </style>
</head>

<body>

<h2>Dual Pulse Nucleoside Labelling - exposure scheduling optimiser</h2>

<div class="section">
  <p>
    <a href="https://www.thermofisher.com/uk/en/home/references/newsletters-and-journals/bioprobes-journal-of-cell-biology-applications/bioprobes-issues-2010/bioprobes-62/dual-pulse-labeling-of-cell-proliferation-with-click-chemistry.html">DPNL</a> is an experimental technique to measure cell cycle dynamics. 
    This tool estimates the optimal waiting time between nucleoside analogue
    exposures based on either observed labelled cell counts or measured phase 
    times. It uses normalisation to choose the closest series in our simulation
    data by relative cell counts or phase times, and returns the optimal time.
  </p>
</div>

<div class="section">
  <strong>Select input method:</strong><br>
  <button onclick="showCounts()">Use Labelled Cell Counts</button>
  <button onclick="showPhases()">Use Cell Cycle Phase Times</button>
</div>


<!-- COUNTS INPUTS -->
<div id="counts" class="inputs section">
  <h3>Counts-based inputs</h3>
  <p>
    Enter observed counts or relative counts from the experiment. All values must be positive.
  </p>

  <label>Inter-pulse waiting time (hours, must be an integer 1-12):
    <input type="number" id="dt" step="1" min="1">
  </label>

  <label>Single-positive count for label 1:
    <input type="number" id="edu" step="any" min="0.001">
  </label>

  <label>Double-positive count:
    <input type="number" id="dp" step="any" min="0.001">
  </label>

  <label>Single-positive count for label 2:
    <input type="number" id="brdu" step="any" min="0.001">
  </label>

  <label>
  G1-S phase optimisation weighting:
  </label>

  <input
    type="range"
    id="s_weight_slider_counts"
    min="0"
    max="1"
    step="0.01"
    value="0.50"
    oninput="syncWeightFromSliderCounts()"
  >

  <input
    type="number"
    id="s_weight_input_counts"
    min="0"
    max="100"
    step="1"
    value="50"
    oninput="syncWeightFromInputCounts()"
  > %

  <p>
  </p>

  <button onclick="runCounts()">Run optimiser</button>
</div>

<!-- PHASE INPUTS -->
<div id="phases" class="inputs section">
  <h3>Phase-time inputs</h3>
  <p>
    Enter preliminary phase duration estimates. All values must be positive.
  </p>

  <label>G1 phase duration (hours):
    <input type="number" id="tg1" step="any" min="0.1">
  </label>

  <label>S phase duration (hours):
    <input type="number" id="ts" step="any" min="0.1">
  </label>

  <label>Total cycle duration (hours):
    <input type="number" id="tc" step="any" min="0.1">
  </label>


  <label>
  G1-S phase optimisation weighting:
  </label>

  <input
    type="range"
    id="s_weight_slider_phases"
    min="0"
    max="1"
    step="0.01"
    value="0.50"
    oninput="syncWeightFromSliderPhases()"
  >

  <input
    type="number"
    id="s_weight_input_phases"
    min="0"
    max="100"
    step="1"
    value="50"
    oninput="syncWeightFromInputPhases()"
  > %

  <p>
  </p>

  <button onclick="runPhases()">Run optimiser</button>
</div>

<div class="section">
  <h3>Results</h3>
  <p>
    Please note there will be up to a 1-minute delay while the optimiser first initialises.
  </p>
  <textarea id="output" readonly></textarea>
</div>

<script>
const API = "https://optimizing-dpnl-scheduling.onrender.com";

function syncWeightFromSliderCounts() {
  const slider = document.getElementById("s_weight_slider_counts");
  const input  = document.getElementById("s_weight_input_counts");
  // const label  = document.getElementById("s_weight_label_counts");

  const percent = Math.round(slider.value * 100);

  input.value = percent;
  // label.textContent = `(${percent}%)`;
}

function syncWeightFromInputCounts() {
  const slider = document.getElementById("s_weight_slider_counts");
  const input  = document.getElementById("s_weight_input_counts");
  const label  = document.getElementById("s_weight_label_counts");

  let percent = Number(input.value);

  if (isNaN(percent)) percent = 0;
  percent = Math.min(100, Math.max(0, percent));

  slider.value = percent / 100;
  label.textContent = `(${percent}%)`;
}

function getSWeightCounts() {
  return Number(document.getElementById("s_weight_slider_counts").value);
}

function syncWeightFromSliderPhases() {
  const slider = document.getElementById("s_weight_slider_phases");
  const input  = document.getElementById("s_weight_input_phases");
  // const label  = document.getElementById("s_weight_label_phases");

  const percent = Math.round(slider.value * 100);

  input.value = percent;
  // label.textContent = `(${percent}%)`;
}

function syncWeightFromInputPhases() {
  const slider = document.getElementById("s_weight_slider_phases");
  const input  = document.getElementById("s_weight_input_phases");
  const label  = document.getElementById("s_weight_label_phases");

  let percent = Number(input.value);

  if (isNaN(percent)) percent = 0;
  percent = Math.min(100, Math.max(0, percent));

  slider.value = percent / 100;
  label.textContent = `(${percent}%)`;
}

function getSWeightPhases() {
  return Number(document.getElementById("s_weight_slider_phases").value);
}

function showCounts() {
  document.getElementById("counts").style.display = "block";
  document.getElementById("phases").style.display = "none";
}

function showPhases() {
  document.getElementById("phases").style.display = "block";
  document.getElementById("counts").style.display = "none";
}

async function runCounts() {
  const dt = Number(document.getElementById("dt").value);
  const edu = parseFloat(document.getElementById("edu").value);
  const dp = parseFloat(document.getElementById("dp").value);
  const brdu = parseFloat(document.getElementById("brdu").value);

  if (dt < 1) {
    alert("Pulse interval cannot be less than 1 hour to compare to the simulation data.");
    return;
  }

  if (dt > 12) {
    alert("Pulse interval cannot be greater than 12 hours to compare to the simulation data.");
    return;
  }

  if (!Number.isInteger(dt)) {
    alert("Inter-pulse waiting time must be an integer to compare to simulation data.");
    return;
  }


  if (edu <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  if (dp <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  if (brdu <= 0) {
    alert("Must have a positive non-zero number of cells.");
    return;
  }

  const sw = getSWeightCounts();

  if (sw < 0) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }
  if (sw > 1) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }

  const g1w = 1-sw;

  const params = new URLSearchParams({ dt, edu, dp, brdu, g1w, sw });

  const r = await fetch(`${API}/optimize/counts?${params}`);
  const d = await r.json();

  const tWait = d["Optimal t_wait"];
  const snr = d["SNR k2 from simulation"];

  document.getElementById("output").value =
    `Optimised waiting time between pulses (counts method): ${tWait} hours

  In the simulation data, we found a maximum signal-to-noise ratio of ${Math.round(snr*10)/10}
  for inference with a ${Math.round(g1w*100)}% G1 weighting and ${Math.round(sw*100)}% S weighting
  on parameters which produced similar counts to the values provided,
  when simulated with a ${tWait} hour waiting time.`;
}

async function runPhases() {
  const tg1 = parseFloat(document.getElementById("tg1").value);
  const ts  = parseFloat(document.getElementById("ts").value);
  const tc  = parseFloat(document.getElementById("tc").value);

  if (tc <= tg1 + ts) {
    alert("Total cycle duration must be greater than G1 + S phase duration.");
    return;
  }

  const sw = getSWeightPhases();

  if (sw < 0) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }
  if (sw > 1) {
      alert("Weight for sw must lay between 0 and 1.");
    return;
  }

  const g1w = 1-sw;

  const params = new URLSearchParams({ tg1, ts, tc, g1w, sw });

  const r = await fetch(`${API}/optimize/phases?${params}`);
  const d = await r.json();
  const tWait = d["Optimal t_wait"];
  const snr = d["SNR k2 from simulation"];

  document.getElementById("output").value =
    `Optimised waiting time between pulses (phase times method): ${tWait} hours

  In the simulation data, we found a maximum signal-to-noise ratio of ${Math.round(snr*10)/10}
  for inference with a ${Math.round(g1w*100)}% G1 weighting and ${Math.round(sw*100)}% S weighting on 
  cells with relative cycle phase times similar to the values provided,
  when simulated on a 24-hour cycle with a ${tWait * 24/tc} hour waiting time.`;
}
</script>

<div class="section">
  <p>
    For more functionality and for documented code from the work, please visit the project's
    <a href="https://github.com/atphelan/optimizing-dpnl-scheduling">GitHub page</a>.
  </p>
  <p>
    Please note that the model used to generate the source data for this optimisation has several caveats.
      1. The simulated cells have a fixed average cycle period of 24 hours.
      2. The cells do not differentiate or migrate such that they would be missed in final DPNL counts.
      3. The cells proliferate continuously, with no quiescence state.
      4. Optimisation assumes 3 repeat measurements of a system with 300 cells at the time of EdU/label
        1 exposure. Simulation reveals slight shifts in the optimal timing with more repeats or cells.
    As such, our model is most ideally suited to early stages of stem-like cancerous cell proliferation.
    Optimal timing conditions are likely to differ by an hour or more with significantly different cells. 
  </p>
</div>

</body>
</html>
